(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{109:function(e,a,t){"use strict";t.d(a,"a",(function(){return u})),t.d(a,"b",(function(){return h}));var r=t(0),n=t.n(r);function c(e,a,t){return a in e?Object.defineProperty(e,a,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[a]=t,e}function o(e,a){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);a&&(r=r.filter((function(a){return Object.getOwnPropertyDescriptor(e,a).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var a=1;a<arguments.length;a++){var t=null!=arguments[a]?arguments[a]:{};a%2?o(Object(t),!0).forEach((function(a){c(e,a,t[a])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(a){Object.defineProperty(e,a,Object.getOwnPropertyDescriptor(t,a))}))}return e}function i(e,a){if(null==e)return{};var t,r,n=function(e,a){if(null==e)return{};var t,r,n={},c=Object.keys(e);for(r=0;r<c.length;r++)t=c[r],a.indexOf(t)>=0||(n[t]=e[t]);return n}(e,a);if(Object.getOwnPropertySymbols){var c=Object.getOwnPropertySymbols(e);for(r=0;r<c.length;r++)t=c[r],a.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(n[t]=e[t])}return n}var l=n.a.createContext({}),d=function(e){var a=n.a.useContext(l),t=a;return e&&(t="function"==typeof e?e(a):s(s({},a),e)),t},u=function(e){var a=d(e.components);return n.a.createElement(l.Provider,{value:a},e.children)},p={inlineCode:"code",wrapper:function(e){var a=e.children;return n.a.createElement(n.a.Fragment,{},a)}},b=n.a.forwardRef((function(e,a){var t=e.components,r=e.mdxType,c=e.originalType,o=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=d(t),b=r,h=u["".concat(o,".").concat(b)]||u[b]||p[b]||c;return t?n.a.createElement(h,s(s({ref:a},l),{},{components:t})):n.a.createElement(h,s({ref:a},l))}));function h(e,a){var t=arguments,r=a&&a.mdxType;if("string"==typeof e||r){var c=t.length,o=new Array(c);o[0]=b;var s={};for(var i in a)hasOwnProperty.call(a,i)&&(s[i]=a[i]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var l=2;l<c;l++)o[l]=t[l];return n.a.createElement.apply(null,o)}return n.a.createElement.apply(null,t)}b.displayName="MDXCreateElement"},81:function(e,a,t){"use strict";t.r(a),t.d(a,"frontMatter",(function(){return o})),t.d(a,"metadata",(function(){return s})),t.d(a,"rightToc",(function(){return i})),t.d(a,"default",(function(){return d}));var r=t(3),n=t(7),c=(t(0),t(109)),o={id:"resource-caching",title:"Resource Caching",slug:"/resource-caching"},s={unversionedId:"resource-caching",id:"resource-caching",isDocsHomePage:!1,title:"Resource Caching",description:"Without any caching, getResource is kind of request intensive, as the complete tree of resources is recreated from the root everytime it is called from the provider. Optimally, we would need to keep a state that remembers already resolved resources, which could be passed to getResource. In the best case, we then only need to resolve the last resource in the path.",source:"@site/docs/resource-caching.md",slug:"/resource-caching",permalink:"/ec.admin/docs/resource-caching",editUrl:"https://github.com/entrecode/ec.admin/edit/master/doc/docs/resource-caching.md",version:"current",sidebar:"someSidebar",previous:{title:"Resource CRUD",permalink:"/ec.admin/docs/resource-crud"},next:{title:"Resource Localization",permalink:"/ec.admin/docs/resource-localization"}},i=[{value:"Problem",id:"problem",children:[]},{value:"Possible Solution",id:"possible-solution",children:[{value:"Automatic Caching",id:"automatic-caching",children:[]},{value:"Cache limit",id:"cache-limit",children:[]}]},{value:"Should this logic really be in the front end?",id:"should-this-logic-really-be-in-the-front-end",children:[]}],l={rightToc:i};function d(e){var a=e.components,t=Object(n.a)(e,["components"]);return Object(c.b)("wrapper",Object(r.a)({},l,t,{components:a,mdxType:"MDXLayout"}),Object(c.b)("p",null,"Without any caching, ",Object(c.b)("a",Object(r.a)({parentName:"p"},{href:"./get-resource"}),"getResource")," is kind of request intensive, as the complete tree of resources is recreated from the root everytime it is called from the provider. Optimally, we would need to keep a state that remembers already resolved resources, which could be passed to getResource. In the best case, we then only need to resolve the last resource in the path."),Object(c.b)("h2",{id:"problem"},"Problem"),Object(c.b)("p",null,'If we request "dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|test|dmAsset", the needed calls are:'),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"let api = new DataManager(env);\n// getResource('dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|test|dmAsset'.split('|'), api)\napi = api.resource('dataManager', '73538731-4ac3-4a1a-b3b5-e31d09e94d42');\napi = api.resource('assetGroup', 'test');\napi.resourceList('dmAsset');\n")),Object(c.b)("p",null,'If we now request "dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|uploads|dmAsset", the same call structure is repeated:'),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"let api = new DataManager(env);\n// getResource('dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|uploads|dmAsset'.split('|'), api)\napi = api.resource('dataManager', '73538731-4ac3-4a1a-b3b5-e31d09e94d42'); // redundant\napi = api.resource('assetGroup', 'uploads'); // only difference\napi.resourceList('dmAsset');\n")),Object(c.b)("h2",{id:"possible-solution"},"Possible Solution"),Object(c.b)("p",null,"So it would be good to have something like:"),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const api = new DataManager(env);\nconst cachedDm = await api.resource('dataManager', '73538731-4ac3-4a1a-b3b5-e31d09e94d42');\ngetResource('dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|test|dmAsset'.split('|'), api, {\n  'dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42': cachedDm,\n});\ngetResource('dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|uploads|dmAsset'.split('|'), api, {\n  'dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42': cachedDm,\n});\n")),Object(c.b)("p",null,'Here, the third argument is a "cache". The call structure could then be:'),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"// first call of getResource\napi = cache['dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42']; // cachedDm\napi = api.resource('assetGroup', 'test'); // only difference\napi.resourceList('dmAsset');\n// second call of getResource\napi = cache['dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42']; // cachedDm\napi = api.resource('assetGroup', 'uploads'); // only difference\napi.resourceList('dmAsset');\n")),Object(c.b)("h3",{id:"automatic-caching"},"Automatic Caching"),Object(c.b)("p",null,"Above, cachedDm was created from the outside, but getResource should also populate cache entries by itself:"),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"const cache = {};\ngetResource('dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|test|dmAsset', api, cache);\n// cache now contains keys:\n// - dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42\n// - dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|test\n\ngetResource('dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|uploads|dmAsset', api, cache);\n// uses \"dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42\" from cache\n// cache now contains keys:\n// - dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42\n// - dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|test\n// - dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|uploads\n")),Object(c.b)("p",null,"Note that the cache will only cache single resources (even path length)"),Object(c.b)("h3",{id:"cache-limit"},"Cache limit"),Object(c.b)("p",null,"The above cache would also need some kind of limitation that will eventually reload cached resources after a certain time, the format could altered to:"),Object(c.b)("pre",null,Object(c.b)("code",Object(r.a)({parentName:"pre"},{className:"language-js"}),"{\n  'dataManager|73538731-4ac3-4a1a-b3b5-e31d09e94d42|assetGroup|test|dmAsset': { timestamp, value }\n}\n")),Object(c.b)("p",null,"getResource then takes a cacheTimeout argument that is considered for each cache entry."),Object(c.b)("h2",{id:"should-this-logic-really-be-in-the-front-end"},"Should this logic really be in the front end?"),Object(c.b)("p",null,"Optimally, this logic would either be part of the ec.sdk, or even on the server side. It does not feel right to implement that as part of a client. The goal: Be able to resolve any resource with 1 request. Currently, ec.sdk expects the client to make one request for each level of the tree that is leading to the target resource. This requires to keep some kind of state that keeps track of the levels of the tree. I think it would be much easier if that state logic would be part of ec.sdk or the server. The client could then just make 1 request for the target resource, while the server will reuse the cached tree levels."))}d.isMDXComponent=!0}}]);